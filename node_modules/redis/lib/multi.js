'use strict';

var utils = require('./utils');

function Multi(client, args) {
    this._client = client;
    this.queue = [["multi"]];
    var command, tmp_args;
    if (Array.isArray(args)) {
        while (tmp_args = args.shift()) {
            command = tmp_args[0];
            tmp_args = tmp_args.slice(1);
            if (Array.isArray(command)) {
                this[command[0]].apply(this, command.slice(1).concat(tmp_args));
            } else {
                this[command].apply(this, tmp_args);
            }
        }
    }
}

Multi.prototype.hmset = Multi.prototype.HMSET = function (key, args, callback) {
    var tmp_args, field;
    if (Array.isArray(key)) {
        if (args) {
            key = key.concat([args]);
        }
        tmp_args = ['hmset'].concat(key);
    } else if (Array.isArray(args)) {
        if (callback) {
            args = args.concat([callback]);
        }
        tmp_args = ['hmset', key].concat(args);
    } else if (typeof args === "object") {
        if (typeof key !== "string") {
            key = key.toString();
        }
        tmp_args = ["hmset", key];
        var fields = Object.keys(args);
        while (field = fields.shift()) {
            tmp_args.push(field);
            tmp_args.push(args[field]);
        }
        if (callback) {
            tmp_args.push(callback);
        }
    } else {
        tmp_args = utils.to_array(arguments);
        tmp_args.unshift("hmset");
    }
    this.queue.push(tmp_args);
    return this;
};

Multi.prototype.send_command = function (command, args, index, cb) {
    var self = this;
    this._client.send_command(command, args, function (err, reply) {
        if (err) {
            if (cb) {
                cb(err);
            }
            err.position = index - 1;
            self.errors.push(err);
        }
    });
};

Multi.prototype.exec = Multi.prototype.EXEC = function (callback) {
    var self = this;
    this.errors = [];
    this.callback = callback;
    this.wants_buffers = new Array(this.queue.length);
    // drain queue, callback will catch "QUEUED" or error
    for (var index = 0; index < this.queue.length; index++) {
        var args = this.queue[index].slice(0);
        var command = args.shift();
        var cb;
        if (typeof args[args.length - 1] === "function") {
            cb = args.pop();
        }
        // Keep track of who wants buffer responses:
        this.wants_buffers[index] = false;
        for (var i = 0; i < args.length; i += 1) {
            if (Buffer.isBuffer(args[i])) {
                this.wants_buffers[index] = true;
                break;
            }
        }
        this.send_command(command, args, index, cb);
    }

    this._client.send_command('exec', [], function(err, replies) {
        self.execute_callback(err, replies);
    });
};

Multi.prototype.execute_callback = function (err, replies) {
    var i, args;

    if (err) {
        if (err.code !== 'CONNECTION_BROKEN') {
            err.errors = this.errors;
            if (this.callback) {
                this.callback(err);
            } else {
                // Exclude CONNECTION_BROKEN so that error won't be emitted twice
                this._client.emit('error', err);
            }
        }
        return;
    }

    if (replies) {
        for (i = 0; i < this.queue.length - 1; i += 1) {
            args = this.queue[i + 1];

            // If we asked for strings, even in detect_buffers mode, then return strings:
            if (replies[i] instanceof Error) {
                var match = replies[i].message.match(utils.errCode);
                // LUA script could return user errors that don't behave like all other errors!
                if (match) {
                    replies[i].code = match[1];
                }
                replies[i].command = args[0].toUpperCase();
            } else if (replies[i]) {
                if (this._client.options.detect_buffers && this.wants_buffers[i + 1] === false) {
                    replies[i] = utils.reply_to_strings(replies[i]);
                }
                if (args[0] === "hgetall") {
                    // TODO - confusing and error-prone that hgetall is special cased in two places
                    replies[i] = utils.reply_to_object(replies[i]);
                }
            }

            if (typeof args[args.length - 1] === "function") {
                if (replies[i] instanceof Error) {
                    args[args.length - 1](replies[i]);
                } else {
                    args[args.length - 1](null, replies[i]);
                }
            }
        }
    }

    if (this.callback) {
        this.callback(null, replies);
    }
};

module.exports = Multi;
